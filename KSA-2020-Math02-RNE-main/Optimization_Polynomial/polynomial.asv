%% 초기값 설정
x1 = 4318; %% 도착점 (x1,y1)의 x좌표 값
y1 = 1730; %% 도착점 (x1,y1)의 y좌표 값
a = 4.2/3.6; %% 속도식 v = asqrt(r-b)에서 사용되는 a
b = 70; %% 속도식 v = asqrt(r-b)에서 사용되는 b
v = 300/3.6; %% v의 최대값(v_max보다 v가 크면 v를 반환함)

%% final model
a2 = 0; %% x(x^2-x0^2)^2항의 계수
a3 = 0; %% x(x^2-x0^2)^3항의 계수
a4 = 0; %% x(x^2-x0^2)^4항의 계수 - 10차이하라고 했지만 odd symmetry때문에 9차식임
ma2 = 10^(-18); %% 이건 Untitled 1226.m 파일에서 미리 10^(-n)들 때려넣으면서 어느정도 variation이 적당한지 감잡은 후에 설정
ma3 = 10^(-25); %% ma2, ma3, ma4 각각 2제곱항, 3제곱항, 4제곱항의 variation 단위이고
ma4 = 10^(-32); %% 처음 10^(-n) 시도후 결과보고 10^(-n-1), 10^(-n-2)로 스케일 맞춰서 더해볼것
% MATLAB은 수천~수만번의 적분을 쉽게 하므로 죄책감을 가지지 말고 일시키자. (단, CPU가 I3이면 좀 조심하자)
% a2, a3, a4는 루프 내에서 사용할 용도고
% 아래의 A2, A3, A4가 default (0,0,0)으로 시작해 실제 최적 계수 기록하는용도임
A2 = 0;
A3 = 0;
A4 = 0;
t0 = timefinal(x1, y1, a, b, 0, 0, 0, v); %8변수(ㄷㄷ) 함수 timefinal 사용

% 요 밑에 p, p', p'' 식들임 (9차식 p 기준)
%p = x.*(y1./x1-y1./(2.*(x1).^3).*(x.^2-(x1).^2)+a2.*(x.^2-(x1).^2).^2+a3.*(x.^2-(x1).^2).^3+a4.*(x.^2-(x1).^2).^4);
%p' = y1./x1-y1./(2.*(x1).^3).*(3.*x.^2-(x1).^2)+a2.*(x.^2-(x1).^2).*(5.*x.^2-(x1).^2)+a3.*(x.^2-(x1).^2).^2.*(7.*x.^2-(x1).^2)+a4.*(x.^2-(x1).^2).^3.*(9.*x.^2-(x1).^2)
%p'' = -3.*y1./(x1).^3.*x+a2.*(20.*x.^3-12.*(x1).^2.*x)+a3.*(x.^2-(x1).^2).*(42.*x.^3-18.*(x1).^2.*x)+a4.*(x.^2-(x1).^2).^2.*(72.*x.^3-24.*(x1).^2.*x)
%(1+(y1./x1-y1./(2.*(x1).^3).*(3.*x.^2-(x1).^2)+a2.*(x.^2-(x1).^2).*(5.*x.^2-(x1).^2)+a3.*(x.^2-(x1).^2).^2.*(7.*x.^2-(x1).^2)+a4.*(x.^2-(x1).^2).^3.*(9.*x.^2-(x1).^2)).^2)./((1+(y1./x1-y1./(2.*(x1).^3).*(3.*x.^2-(x1).^2)+a2.*(x.^2-(x1).^2).*(5.*x.^2-(x1).^2)+a3.*(x.^2-(x1).^2).^2.*(7.*x.^2-(x1).^2)+a4.*(x.^2-(x1).^2).^3.*(9.*x.^2-(x1).^2)).^2).^(3/2)/((-3.*y1./(x1).^3.*x+a2.*(20.*x.^3-12.*(x1).^2.*x)+a3.*(x.^2-(x1).^2).*(42.*x.^3-18.*(x1).^2.*x)+a4.*(x.^2-(x1).^2).^2.*(72.*x.^3-24.*(x1).^2.*x)).^2).^(1/2)-b).^(1/2);

%% Main Loop
% 대망의 루프 시작: i, j, k가 각각 a2, a3, a4에 해당됨
for i = 120:140
    a2 = i*ma2;
    for j=-50:-30
        a3 = j*ma3;
        for k=-20:20
            a4 = k*ma4;
            tr = timefinal(x1, y1, a, b, a2, a3, a4, v);
            if tr<t0
                A2 = a2;
                A3 = a3;
                A4 = a4;
                t0 = tr;
            end
        end
    end
            
            
end

%% Outputs
% 요 밑에 t0 하나만 썼다고 MATLAB이 시비거는데 어쨌든 시간 출력해야되니까 무시하자.
t0
% deg9sol이 철도 그래프 그리는거고
deg9sol = @(x) y1/x1.*x-y1/(2*(x1)^3).*x.*(x.^2-(x1)^2)+A2.*x.*(x.^2-(x1)^2).^2+A3.*x.*(x.^2-(x1)^2).^3+A4.*x.*(x.^2-(x1)^2).^4;
fplot(deg9sol, [0,x1],'Linewidth',1)
% deg9vel이 속도그래프
deg9vel = @(x) (a.*((1+(y1./x1-y1./(2.*(x1).^3).*(3.*x.^2-(x1).^2)+a2.*(x.^2-(x1).^2).*(5.*x.^2-(x1).^2)+a3.*(x.^2-(x1).^2).^2.*(7.*x.^2-(x1).^2)+a4.*(x.^2-(x1).^2).^3.*(9.*x.^2-(x1).^2)).^2).^(3/2)./((-3.*y1./(x1).^3.*x+a2.*(20.*x.^3-12.*(x1).^2.*x)+a3.*(x.^2-(x1).^2).*(42.*x.^3-18.*(x1).^2.*x)+a4.*(x.^2-(x1).^2).^2.*(72.*x.^3-24.*(x1).^2.*x)).^2).^(1/2)-b).^(1/2)+v-((a.*((1+(y1./x1-y1./(2.*(x1).^3).*(3.*x.^2-(x1).^2)+a2.*(x.^2-(x1).^2).*(5.*x.^2-(x1).^2)+a3.*(x.^2-(x1).^2).^2.*(7.*x.^2-(x1).^2)+a4.*(x.^2-(x1).^2).^3.*(9.*x.^2-(x1).^2)).^2).^(3/2)./((-3.*y1./(x1).^3.*x+a2.*(20.*x.^3-12.*(x1).^2.*x)+a3.*(x.^2-(x1).^2).*(42.*x.^3-18.*(x1).^2.*x)+a4.*(x.^2-(x1).^2).^2.*(72.*x.^3-24.*(x1).^2.*x)).^2).^(1/2)-b).^(1/2)-v).^2).^(1/2))/2;
%fplot(deg9vel, [0,x1],'Linewidth',1)


%% 여기부터는 수치해석 결과 기록용
%Deg9Poly - final velocity - SRT parallel transition
% x1 = 4318
% y1 = 1730
% v = 300/3.6
% A2 = 1.31*10^(-16)
% A3 = -4.2*10^(-24)
% A4 = -3.0*10^(-32)
% t0 = 56.7728 <-- Time from deg9poly
% Dy1 = 0.78: time = 56.8979 <-- Time from 변분해, 최적의 기울기 m
% Dy2 = 0.97: time = 57.2409 <-- Time from 변분해, 현실 기울기


%Deg9Poly - final velocity - Line3 parallel transition
% x1 = 471
% y1 = 319.5
% v = 



